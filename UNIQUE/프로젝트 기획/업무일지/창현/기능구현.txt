기능을 최 우선적으로는 프론트엔드 입장에서 생각한다
유저의 동작에 따라서 어떠한 기능이 필요한지 따라나오는 것이 좋을듯


# 지갑 관리
지갑 생성
지갑 가져오기
지갑 조회

# 토큰 관리
이더 충전 ( 수수료, 가스비 )
토큰 구매 ( 서비스 내부적으로 사용하는 화폐 )
토큰 잔액조회

# NFT 상품
NFT 상품 등록
상품 판매 등록
상품 판매 취소
상품 즉시 구매
상품 경매 입찰





지갑 생성
1. 프론트에서 자체적으로 지갑을 생성한다
	 - web3 라이브러리를 사용하여 지갑을 생성한다
	 - 그렇게 생성된 정보를 뒤에서 전송함
	 - 지갑 생성 시, 사용자가 개인 키를 별도로 각별히 관리하도록 주의를 주거나, 자동으로 백업을 지원해야한다
	 - 개인 키를 잃어버리는 상황이 없어야 할 것
	 - 지갑 주소 & 지갑 비밀 키 => 생성되는 정보
2. 생성한 지갑을 BE로 전송하여 DB에 정보를 등록한다
	 - 생성된 정보 중에서 지갑의 주소만 전송을 할 것
	 - 개인 키는 개별로 관리해야할 것
3. response





지갑 가져오기
 - 진짜 존재하는 지갑인지 확인하기 위해서, 지갑 주소와 개인키를 이용해서 확인한다
 - 확인이 끝나면, 해당 지갑을 BE로 전송하여 DB에 정보를 등록한다





지갑 조회
1. FE에서 BE로 지갑조회를 요청한다
	 - 현재 유저가 보유하고 있는 지갑이 하나 뿐인지 여러개가 될 수 있는지 알아야 한다
	 - 그것에 따라 지갑 주소를 받아서 동작할지, 현재 유저의 지갑 주소를 찾아서 동작할지 정할 수 있다
2. BE에서 이더리움 네트워크로 지갑 주소를 사용하여 지갑정보검색을 요청한다
	 - 어쨌든 지갑 주소를 사용해서 이더리움 네트워크에 지갑정보 검색을 요청하면, 그 안에 여러 데이터가 있을 것
3. 이더리움 네트워크에서 주소 정보 response
	 - 지갑 정보에 대한 response 내용이 DB에 자리가 있어야 할 것
4. 잔액정보를 확인하고, DB의 잔액정보와 다르다면, DB를 최신화 한다
	 - 잔액 정보 같은 것이 지갑에 저장되어 있을 것
	 - 잔액 이더 정보도 있고, 잔액 토큰 정보도 있을 것
	 - 이러한 부분을 최신화 해야한다
5. 지갑정보 response





이더 충전
 - 이더는 우리가 다루는 것이 아닐 것 같다
 - 각자 알아서 자신의 지갑에 이더를 충전해야 할 것
 - 그렇다면, 실제 서비스에서는 카카오뱅크를 연결해서 결제하던지 하는 시스템이 존재하는 건가?
 - 일단 이더가 있다는 가정 하에 서비스를 진행해보는 것도 괜찮지 않을까?
 - 어짜피 프라이빗 네트워크를 사용하면 이더 자체는 문제가 크게 되지 않을 수 있다




코인 충전
1. FE에서 BE로 충전을 요청한다
	 - 코인 충전을 하려면 이더를 가지고 코인으로 변경하는 작업? 이 필요할 듯
	 - 이더를 가지고 충전을 한다면, 현재 이더를 가지고 코인으로 변경할 수 있는지 알아야 할것
2. BE에서 이더리움 네트워크로 충전 트랜잭션을 생성
	 - 이더리움 네트워크에서 충전 트랜잭션을 통해서 이더를 받고 토큰을 주는 작업을 할 것
3. 트랜잭션 결과 response
	 - 충전을 한 다음, 이더나 토큰의 잔액정보를 refresh해서 DB에 저장할 수 있어야 할것
	 - 즉, 트랜잭션 결과를 return 하면서 더 다양한 정보를 받을 수 있어야 할 것 같다
	 - 그냥 트랜잭션 무사히 끝났다는 정보가 아니라, 트랜잭션 결과 지갑의 정보가 어떻게 수정되었다 정도로
4. 충전 후 예상 금액 응답





토큰 잔액조회, 이더 잔액조회
 - 잔액정보는 지갑조회를 진행하면서 동시에 refresh된다
 - 그렇다면, 지갑 조회 없이 내부 정보가 바뀌는 경우도 있는가?
 - 그런 경우가 없다면, 굳이 이더리움 네트워크에 접근하지 않고 잔액조회를 해줄 수 있을 것이다
 - 미리 wallet DB안에 해당 정보를 위한 자리를 만들어야할 것





NFT 상품 등록
1. 작품 등록 요청
	 - 파일을 백엔드로 전송
2. 원본 업로드
	 - 백에서 파일을 받아서 유일성 검사를 진행할 수 있어야 한다
	 - 파일 자체보다는 메타데이터가 중요하다고 한다
	 - 업로드한 
3. 업로드 URI
4. URI response
5. NFT 생성
6. response
7. 작품 업데이트 (token_id, owner_address)
8. response











